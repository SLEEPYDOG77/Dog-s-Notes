# 算法整理 - 2栈与队列

[TOC]

## 一、栈

### （一）顺序栈的基本操作

#### 1. 类型定义

```c
#define MaxSize 100
typedef struct {
  int data[MaxSize];
  int top;
} sqStack;

sqStack stack;
```



#### 2. 六大要点

##### （1）栈空

```c
stack.top = -1;
```

##### （2）栈满

```c
stack.top == MaxSize - 1;
```

##### （3）进栈

```c
stack.top ++;
stack.data[stack.top] = x;

// stack.data[++(stack.top)] = x;
```

##### （4）出栈

```c
x = stack.data[stack.top];
stack.top --;

// x = stack.data[(stack.top)--];
```

##### （5）上溢

> 栈满时，继续入栈就会上溢。

##### （6）下溢

> 栈空时，继续出栈就会下溢。



#### 3. 初始化

```c
void initStack(sqStack *stack) {
  stack->top = -1;
}
```



#### 4. 判断是否栈空

```c
int isEmpty(sqStack *stack) {
  if(stack->top < 0) 
    return 1;
  else return 0;
}
```



#### 5. 判断是否栈满

```c
int isFull(sqStack *stack) {
  if (stack->top == MaxSize - 1) 
    return 1;
  else return 0;
}
```



#### 6. 向顺序栈中插入元素（push 进栈）

> - 检查栈是否已满
>   - 若栈满，则进行 “上溢” 错误处理
>   - 若栈未满，将栈顶指针加 1， 使之指向下一个空单元
> - 将新结点的值赋给栈顶指针所指向的单元

```c
int push(sqStack *stack, int x) {
  if(stack->top == MaxSize - 1) {
    printf("栈满溢出错误\n");
    return 0;
  } else {
    stack->top++;
    stack->data[stack->top] = x;
  }
  return 1;
}
```



#### 7. 从顺序栈中删除栈顶元素（pop 出栈）

> - 检查栈是否已空
>   - 若栈空，则进行 “下溢” 错误处理
>   - 若栈不空，保留或暂存栈顶元素以便返回给调用者
> - 将栈顶指针减1

```c
int pop(sqStack *stack, int &x) {
  if(stack->top < -1) {
    printf("栈空下溢错误\n");
    return 0;
  } else {
    x = stack->data[stack->top];
    stack->top --;
  }
  return 1;
}
```



### （二）链栈的基本操作

#### 1. 类型定义

```c
typedef struct LNode {
  int data;
  LNode *next;
}LNode;

LNode *stack;
// stack->next 指向栈顶元素
```



#### 2. 四大要点

##### （1）栈空

```c
stack->next = NULL;
```

##### （2）栈满

> 理论上不存在栈满。

##### （3）进栈

```c
p->next = stack->next;
stack->next = p;
```

##### （4）出栈

```c
p = stack->next;
x = p->data;
stack->next = p->next;
```



#### 3. 初始化

```c
void initStack(LNode *stack) {
  stack->next = NULL;
}
```



#### 4. 判断是否栈空

```c
int isEmpty(LNode *stack) {
  if(stack->next == NULL)
    return 1;
  else return 0;
}
```



#### 5. 判断是否栈满

> 理论上不存在栈满。
>
> 一般只会判断 malloc( ) 分配新结点是否成功。



#### 6. 进栈（push）

> - malloc( ) 函数申请新结点
> - 若申请成功，将新结点插入栈顶

```c
int push(LNode *stack, int x) {
  LNode *p = (LNode*) malloc(sizeof(LNode));
  if(p == NULL) 
    return 0;
  
  p->data = x;
  p->next = stack->next;
  stack->next = p;
  return 1;
}
```



#### 7. 出栈（pop）

> - 先判断链栈是否为空
> - 若不空，暂存栈顶结点
> - 修改栈顶指针指向新的栈顶

```c
int pop(LNode *stack, int &x) {
  LNode *p;
  if(stack->next == NULL)
    return 0;
  
  p = stack->next;
  x = p->data;
  stack->next = p->next;
  free(p);
  return 1;
}
```



### （三）栈的应用

#### 1. 数制转换问题

#### （1）问题描述

> 将十进制数 N 转换为 r 进制的数。

#### （2）算法思想

> 利用**顺序栈**和**辗转相除法**
>
> - 若 N ≠ 0，则将 N% r 压入栈 stack 中， N = N / r
> - 若 N = 0，将栈 stack 的内容依次出栈

#### （3）代码实现

```c
#define L 10
void conversion(int N, int r) {
  // 初始化栈
  int stack[L];
  int top = -1;
  int x;
  
  // N ≠ 0 辗转相除入栈
  while(N) {
    stack[++top] = N % r;
    N = N / r;
  }
  
  // 若栈不为空，出栈
  
}
```



#### 2. 表达式求值

##### （1）问题描述

> 求后缀表达式的值。

##### （2）算法思想

> 对于一个后缀式，当从左往右扫描，当扫描到一个数值时，具体怎么运算，此时还不知道，需要扫描到后面的运算符才知道，因此必须将数值存起来，利用栈来解决。
>
> - 从左到右扫描：
>   - 当遇到数值的时候入栈
>   - 当遇到运算符的时候，连续两次出栈，将两个出栈元素结合运算符进行运算，将结果当成新的数值入栈。
> - 如此往复，直到扫描到终止符 '\0' 
> - 此时栈底元素即为表达式的值。

##### （3）代码实现

```c
int operate(int a, char op, int b) {
  if(op == '+') return a+b;
  if(op == '-') return a-b;
  if(op == '*') return a*b;
  if(op == '/'){
    if (b == 0) {
      printf("ERROR!");
      return 0;
    } else return a/b;
  }
}

int com(char exp[]) {
  int i, a, b, c;
  int stack[maxSize];
  int top = -1;
  
  char op;
  for(i = 0; exp[i] !='\0'; i++) {
    if(exp[i] >= '0' && exp[i] <= '9')
      stack[++top] = exp[i] - '0';
    else {
      op = exp[i];
      b = stack[top--];
      a = stack[top--];
      
      c = op(a, op, b);
      stack[++top] = c;
    }
  }
  return stack[top];
}
```



#### 3. 括号匹配问题

##### （1）问题描述

> 判断一个表达式中的括号（'( )'、'[ ]'、'{ }'）是否正确配对。

##### （2）算法思想

> 从左到右扫描表达式，

