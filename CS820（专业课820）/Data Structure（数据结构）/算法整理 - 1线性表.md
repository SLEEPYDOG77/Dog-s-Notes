# 算法整理 - 1线性表

[TOC]



## 一、线性表

### （一）顺序表的基本操作

##### 定义

> 用一维数组存储数据，再用一个 int 型变量表示表长。

```c
#define maxSize 100
typedef struct {
  int data[maxSize];
  int length;
}Sqlist;
```



##### 创建

```c
Sqlist L;
```



##### 初始化

```c
void InitList(Sqlist &L) {
  L.length = 0;
}
```



##### 遍历

```C
void TraverseList(Sqlist L) {
  int i;
  for (i = 0; i < L.length; i++) {
    printf("%d\t", L.data[i]);
  }
}
```



##### 查找顺序表中的元素

> - 遍历顺序表
> - 对比遍历的每一个元素与要查找元素的值。
>   - 若相等，则返回位置；
>   - 否则，返回0。

```c
int Locate(Sqlist L, int e) {
  int i, result = 0;
  for(i = 0; i < L.length; i++){
    if (data[i] == e){
      result = i+1;
      break;
    }
  }
  return result;
}
```



##### 在顺序表中插入数据元素

> - 判断是否能插入
>   - 若插入位置 p 小于 0 或 p 大于顺序表表长，或顺序表已达到最大长度，均无法插入
> - 从后往前将 p 之后的元素右移一个位置
> - 将 e 插入到 p 位置上，表长加 1，返回位置 i

```c
int InsertElem(Sqlist &L, int p, int e) {
  int i;
  if(p < 0 || p > L.length || L.length == maxSize)
    return 0;
  
  for(i = L.length-1; i >= p; --i)
    L.data[i+1] = L.data[i];
  
  L.data[p] = e;
  ++(L.length);
  
  return i;
}
```



##### 删除顺序表中指定元素

> - 判断是否能删除
>   - 若删除位置 p 小于0 或 p 大于顺序表表长，则无法删除，返回 0
> - 用 e 存储要删除的 p 位置上的元素
> - 从 p 位置开始，将其后边的元素逐个前移一个位置，将要删除的元素覆盖即可

```c
int DeleteElem(Sqlist &L, int p, int &e) {
  int i;
  if(p < 0 || p > L.length - 1)
    return 0;
  
  e = L.data[p];
  
  for(i = p; i < L.length-1; i++) 
    L.data[i] = L.data[i+1];
  
  --(L.length);
  return 1;
}
```



### （二）单链表的基本操作

##### 定义

```c
typedef struct LNode{
  int data;
  struct LNode *next;
}LNode;
```



##### 初始化

```c
LNode *head = NULL;

int InitList(LNode *head){
	head = (LNode*)malloc(sizeof(LNode));
	if(!head)
		return 1;
  else return 0;
}
```



遍历

```c
void Traverse(LNode *head) {
  LNode *p;
  p = head -> next;
  while(p!= NULl){
    printf("%d\t", p->data);
    p = p->next;
  }
}
```



##### 查找单链表中元素

> - 遍历整个链表
> - 对比链表中每个结点的值，与要查找的值是否相等
>   - 成功则返回该结点指针
>   - 失败则返回 NULL

```c
LNode* SearchNode(LNode *head, int x) {
  LNode *p;
  p = head->next;
  
  while(p != NULL) {
    if(p->data != x)
      p = p->next;
    else
      break;
  }
  return p;
}
```



##### 在单链表中插入数据元素

###### 头插法

> - 生成一个新结点，将要插入的值存入该结点
> - 用头指针将结点链接到链表最前

```c
void InsertLinkF(LNode &head, int x) {
	LNode *p;
  p = (LNode*)malloc(sizeof(LNode));
  
  if (p!=NULL) {
    p->data = x;
  	p->next = head->next;
  	head->next = p;
  }
}
```



###### 尾插法

> - 申请一个尾指针
> - 遍历链表，将尾指针指向链表的最后一个结点
> - 生成一个新结点，将要插入的值存入该结点
> - 用尾指针将结点链接到链表最后

```c
void InsertLinkR(LNode &head, int x) {
  LNode *p, *pre;
  pre = head;
  
  while(pre!=NULL) {
    if(pre->next == NULL)
      break;
    pre = pre->next;
  }
  
  p = (LNode*)malloc(sizeof(LNode));
  p->data = x;
  p->next = NULL;
  pre->next = p;
}
```



###### 头插法建立链表

```c
void CreateListF(LNode *&head, int a[], int n) {
  LNode *p;
  int i;
  
  head = (LNode*)malloc(sizeof(LNode));
  head->next = NULL;
  
  for(i = 0; i < n; i++) {
    p = (LNode*)malloc(sizeof(LNode));
    p->data = a[i];
    p->next = head->next;
    head->next = p;
  }
}
```



###### 尾插法建立单链表

```c
void CreateListR(LNode *&head, int a[], int n) {
  LNode *p, *pre;
  int i;
  
  head = (LNode*)malloc(sizeof(LNode));
  head->next = NULL;
  
  pre = head;
  for (i = 0; i< n; i++) {
    p = (LNode*)malloc(sizeof(LNode));
    p->data = a[i];
    pre->next = p;
    pre = pre->next;
  }
  pre->next = NULL;
}
```



##### 删除单链表中某个元素

> - 申请两个指针，用于存储被删除结点以及被删除结点的前驱
> - 遍历链表，找到被删除元素的结点
> - 通过将被删除结点的前驱指向被删除结点的后继来使被删除结点脱离链表
> - 调用 free 函数来释放被删除元素的存储空间

```c
int DeleteLink(LNode *head, int x) {
  LNode *pre, *p;
  pre = head;
  p = head->next;
  
  while(p!= NULL) {
    if(p->data == x)
      break;
    pre = p;
    p = p->next;
  }
  
  if (p == NULL)
    return 0;
  
  pre->next = p->next;
  free(p);
  return 1;
}
```



##### 两个有序单链表的合并

```c
LNode* LinkMerge(LNode *head1, LNode *head2) {
  if(!head1) return head2;
  if(!head2) return head1;
  
  LNode *head = NULL;
  LNode *p1 = head1;
  LNode *p2 = head2;
  LNode *p = head;
  
  if(head1->data < head2->data) {
    head = head1;
    p1 = head1->next;
  } else {
    head = head2;
    p2 = head2->next;
  }
  
  while(p1 && p2) {
    if (p1->data < p2->data) {
      p->next = p1;
      p1 = p1->next;
    } else {
      p->next = p2;
      p2 = p2->next;
    }
    p = p->next;
  }
  
  if (p1){
    p->next = p1;
  } else if(p2){
    p->next = p2;
  }

  return head;
}
```



### （三）双链表的基本操作

##### 定义

```c
typedef struct DLNode {
  int data;
  struct DLNode *prior;
  struct DLNode *next;
} DLNode;
```



##### 创建

```c
DLNode* CreateDLink(int x) {
  DLNode *p = NULL;
  p = (DLNode*)malloc(sizeof(DLNode));
  p->data = x;
  return p;
}
```



##### 查找结点

> - 遍历整个链表
> - 边遍历边比较
>   - 若找到值为x的结点，则返回该结点指针
>   - 否则，返回 NULL

```c
DLNode* SearchNode(DLNode* head, int x){
  DLNode *p = head->next;
  while(p!=NULL) {
    if(p->data == x)
      break
    p = p->next;
  }
  return p;
}
```



##### 插入结点

> - 遍历链表，找到第i个位置
> - 申请一个结点，将要插入的值存入结点
> - 将该结点插入到 i 位置之后

```c
int InsertDLink(DLNode *head, int i, int e) {
  DLNode *pre, *p;
  int count = 0;
  pre = head;
  
  while(p!= NULL) {
    if (count == i)
      break;
    pre = pre->next;
  }
  
  p = (DLNode*)malloc(sizeof(DLNode));
  if(!p)
    return 0;
  
  p->data = e;
  p->next = pre->next;
  p->prior = pre;
  pre->next = p;
  p->next->prior = p;
  
  reutrn 1;
}
```



##### 删除结点

```c
int DeleteDLink(DLNode *head, int e) {
  
}
```



## 二、课后习题 - 天勤

### 综合应用题

#### 1. 基础题

##### （3）设计一个算法，将顺序表中的所有元素逆置。

> - 假设 n 为顺序表长度，从 0 到 n/2 遍历顺序表。
> - i 指向当前遍历的元素下标，将下标 i 指向的元素与第 n - 1 - i 下标指向的元素对换即可。

```c
#define maxSize 100
typedef struct{
  int data[maxSize];
  int length;
}Sqlist;

Sqlist L;

void Reverse(Sqlist &L) {
  int i;
  int temp;
  int n = L.length;
  for (i = 0; i < n / 2; i++) {
    temp = L.data[i];
    L.data[i] = L.data[n-1-i];
    L.data[n-1-i] = temp;
  }
}
```



> - 两个变量i、j 指示顺序表的第一个元素和最后一个元素
> - 交换i、j所指元素，然后 i 向后移动一个位置，j 向前移动一个位置
> - 直到 i 和 j 相遇为止

```c
void reverse(Sqlist &L) {
  int i,j;
  int temp;
  for(i=0,j=L.length-1; i<j; i++,j--){
    temp = L.data[i];
    L.data[i] = L.data[j];
    L.data[j] = temp;
  }
}
```



##### （4）设计一个算法，从一给定的顺序表 L中删除下标 i~j（i ≤ j，包括i、j）的所有元素，假定i、j都是合法的。

> 从第 j+1 个元素开始到最后一个元素为止，用这之间的每个元素去覆盖从这个元素开始往前数第 j-i+1 个元素。
>
> 表长减去 j-i+1。

```c
void delete(Sqlist &L, int i, int j) {
  int k, delta;
  delta = j-i+1;
  for(k = j+1; k < L.length; k++) {
    L.data[k-delta] = L.data[k];
  }
  L.length -= delta;
}
```



##### （5）有一个顺序表 L，其元素为整型数据，设计一个算法，将 L 中所有小于表头元素的整数放在前半部分，大于表头元素的整数放在后半部分。

> - 先将 L 的第一个元素存在变量 temp 中。
> - 定义两个整型变量 i 和 j。i 从左往右扫描，j 从右往左扫描，边扫描边交换。
>   - 当 i 找到比表头元素大的元素时，将 i 所指元素放入 j 所指位置，i 停在当前位置不动，j 向左移动一位。
>   - 当 j 找到比表头元素小的元素时，将 j 所指元素放入 i 所指位置，j 停在当前位置不动，i 向右移动一位。
> - 直到 i==j 为止。

```c
void move(Sqlist &L) {
  int temp;
  int i = 0, j = L.length - 1;
  temp = L.data[i];
  
  while(i < j) {
    while(i < j && L.data[j] < temp)
      j--;
    
    if(i < j) {
      L.data[i] = L.data[j];
      i++;
    }
    
    while(i < j && L.data[i] > temp)
      i++;
    
    if (i < j) {
      L.data[j] = L.data[i];
      j--;
    }
  }
  L.data[i] = temp;
}
```



##### （6）有一个递增非空单链表，设计一个算法删除值域重复的结点。

> - 定义指针 p 指向起始结点。将 p 所指的当前结点值域和其直接后继结点值域做比较。
>   - 如果当前结点值域等于后继结点值域，则删除后继结点；
>   - 否则 p 指向后继结点。
> - 直到 p 的后继结点为空为止。

```c
void deleteDup1(LNode *L) {
  LNode *pre = L->next, *p;
  
  while(pre->next != NULL) {
    if(pre->data == pre->next->data){
      p = pre->next;
      pre->next = p->next;
      free(p);
    } else {
      pre = pre->next;
    }
  }
}
```



> - 依次将原序列中每个连续相等子序列的第一个元素移动到表的前端
> - 将剩余的元素删除即可。

```c
void deleteDup2(LNode *L) {
  LNode *pre = L->next, *p = L->next->next, *r;
  while(p != NULL) {
    while(p != NULL && p->data == pre->data)
      p = p->next;
    
    if(p != NULL) {
      pre = pre->next;
      pre->data = p->data;
    }
    
    p = pre->next;
    pre->next = NULL;
    
    while(p!=NULL){
      r = p;
      p = p->next;
      free(r);
    }
  }
}
```



##### （7）设计一个算法删除单链表L（有头结点）中的一个最小值结点。

> - 先要遍历找到最小值，一个指针 pre 指向最小值的前驱结点（便于进行删除操作）
> - 遍历完成后随即通过 pre 删除最小值结点

```c
void deleteMin(LNode *L){
  LNode *pre, *p, *minp, *minpre;
  int min;
  p = L->next;
  min = p->data;
  pre = L;
  minp = p;
  minpre = pre;
  
  while(p != NULL) {
    if (p->data < minp->data){
      minp = p;
      minpre = pre;
    }
    pre = p;
    p = p->next;
  }
  
  minpre->next = minp->next;
  free(minp);
}
```



##### （8）有一个线性表，采用带头结点的单链表 L 来存储。设计一个算法将其逆置。要求不能建立新结点，只能通过已有结点的重新组合来完成。

> - 将头结点后的一连串结点用头插法插入。

```c
void reverse(LNode *L) {
  LNode *p = L->next, *q;
  L->next = NULL;
  while(p != NULL) {
    q = p->next;
    p->next = L->next;
    L->next = p;
    p = q;
  }
}
```



##### （9）设计一个算法，将一个头结点为 A 的单链表（其数据域为整数）分解成两个单链表 A 和 B，使得 A 链表只含有原来链表中 data 域为奇数的结点，而 B 链表只含有原链表中 data 域为偶数的结点，且保持原来的相对顺序。

> - 用指针 p 从头到尾扫描 A 链表，当发现结点 data 域为偶数的结点则取下，插入链表 B 中。
> - 为保持原来数据元素的相对元素，插入 B 链表时应采用尾插法。

```c
void splitLink(LNode *A, LNode *&B) {
  LNode *p;				// 指向当前遍历结点
  LNode *qa;			// 指向从链表A中取下的结点
  LNode *qb;			// 指向链表B中当前插入位置（链尾）
  B = (LNode*)malloc(sizeof(LNode));
  B->next = NULL;
  
  qb = B;
  p = A;
  while(p->next != NULL) {
    if(p->next->data%2 == 0){
      qa = p->next;
      p->next = qa->next;
      qb->next = qa;
      qb = qa;
    }
  } else p = p->next;
}
```



#### 2. 思考题

##### （1）有 N 个个位正整数存在 int 型数组 A[0, ... , N-1]中，N 为已定义的常量且 N ≤ 9，数组 A[ ] 的长度为 N，另给一个 int 型变量 i，要求只用上述变量（A[0] ~ A[N-1]与i，这 N+1 个整型变量）写一个算法，找出这 N 个整数中的最小者，并且要求不能破坏数组 A[] 中的数据。

> 通常在顺序表中找最小值，需要一个循环变量 i 来控制循环和一个始终记录当前所扫描序列中最小值的变量 min。但本题 A[0] ~ A[N-1] 的数据不能被破坏，就只剩下一个变量 i ，需要用来实现“循环控制”和“记录最小值”这两个功能。
>
> 但很妙的是，题目还给出了一个条件，即数组长度不超过 9！而 i 是 int 型变量，于是可以考虑将其十位的数字（i%10）作为循环变量，再用个位上的数字（i/10）用于记录数组中最小值的下标。

```c
void findMin(int A[], int &i) {
  i = A[0];
  while(i/10 <= N-1) {
    if(i%10 > A[i/10]) {
      i = i - i%10;
      i = i + A[i/10];
    }
    i = i + 10;
  }
  i = i%10;
}
```



##### （2）写一个函数，逆序打印单链表中的数据，假设指针 L 指向了单链表的开始结点。

> - 先用头插法实现逆序
> - 再从头到尾打印

```c
void reversePrint(LNode *L) {
  
}
```



> 用递归的方法解决：
>
> - 在表不空的情况下先递归地逆序打印表中第一个数据之后的数据
> - 然后打印第一个数据

```c
void reversePrint(LNode *L) {
 if(L != NULL) {
   reversePrint(L->next);
   printf("%d\t", L->data);
 } 
}
```



##### （3）试编写一个算法，以不多于 3n/2 的平均比较次数，在一个有 n 个整数的顺序表 A 中找出最大值和最小值。

> 只扫描一趟即可找出最大值和最小值。算法时间复杂度分析如下：
>
> - 最坏情况：表中 n 个整数按从大到小非递增排列时，数据比较次数为 2(n-1) 次
> - 最好情况：表中 n 个整数按从小到大递增排列时，数据比较次数为 n-1 次
>
> 数据的有序性是等可能的，因此平均比较次数为 [2(n-1) + (n-1)] / 2 = 3n / 2。

```c
void findMaxAndMin(int A[], int n, int &max, int &min) {
  max = A[0];
  min = A[0];
  int i;
  
  for (i = 1; i < n-1; i++) {
    if (A[i] > max)
      max = A[i];
    else if(A[i] < min)
      min = A[i];
  }
}
```



##### （4）设 A = (a1, a2, ... , am) 和 B = (b1, b2, ... bn) 均为顺序表，A' 和 B' 分别是除去最大公共前缀后的子表。若 A' = B' = 空表，则 A = B；若 A' = 空表且 B' ≠ 空表，或两者均不为空且 A' 的第一个元素值小于 B' 的第一个元素值，则 A ＜ B，否则 A ＞ B。试编写一个函数，根据上述方法比较 A 和 B 的大小。

> - 先进行一趟遍历，过滤掉最大公共前缀
> - 再根据题目所给算法，判断剩余部分，以确定 A 和 B 的大小。
>
> 假设 A 与 B 中元素值为 float 型。
>
> - 若 A = B，返回 0
> - 若 A ＜ B，返回 -1
> - 若 A ＞ B，返回 1

```c
int compare (float A[], int An, float B[], int Bn) {
  int i = 0;
  while(i < An && i < Bn) {
    if(fabs(A[i] - B[i]) < min)
      i++;
    else 
      break;
  }
  
  if (i >= An && i >= Bn) {
    return 0;
  } else if ((i >= An && i < Bn) || A[i] < B[i]) {
    return -1;
  } else 
    return 1;
}
```



## 三、真题整理



