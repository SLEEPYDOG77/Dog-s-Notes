# 820操作系统 简答题整理

[TOC]



### 【绪论】

##### 1. 操作系统的四个特征？

> - 并发
> - 共享
> - 虚拟
> - 异步



##### 2. 大内核与微内核的优缺点？

> - 大内核是指将操作系统的主要功能模块都作为系统内核，运行在内核态
>   - 优点：高性能
>   - 缺点：内核代码庞大，结构混乱，难以维护
> - 微内核是指只把最基本的功能保留在内核
>   - 优点：内核功能少，结构清晰，方便维护
>   - 缺点：需要频繁地在核心态和用户态之间切换，性能低



##### 3. 中断的概念及外中断的处理过程？

> 发生了中断，就意味着需要操作系统介入，开展管理工作。中断可以使CPU从用户态切换为和心态，使操作系统获得计算机的控制权。
>
> - 内中断（也称异常、陷入）
>   - 指令中断，如trap指令
>   - 硬件故障，如缺页 
>   - 软件中断，如整数除0
> - 外中断（常说的中断）
>   - 外设请求，如I/O操作完成发生的中断信号
>   - 人工干预，如用户强行终止一个进程
>
> 中断的处理过程：
>
> - 执行完每个指令之后，CPU都要检查当前是否有外部中断信号。
> - 如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器等）。
> - 根据中断信号类型转入相应的中断处理程序。
> - 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行。



##### 4. 脱机I/O和联机I/O

> - 脱机输入输出方式是为了解决人机矛盾及CPU和I/O设备之间速度不匹配而提出的。
>   - 它减少了CPU的空闲等待时间，提高了I/O速度。
>   - 将用户程序和数据在一台外围机的控制下，预先从低速输入设备输入到磁带上，当CPU需要这些程序或数据时，再直接从磁带机高速输入到内存，从而大大加快了程序的输入过程，减少了CPU等待输入的时间。
>   - 当程序运行完毕或告一段落，CPU需要输出时，无需直接把计算结果送至低速输出设备，而是高速把结果输出到磁带上，然后在外围机的控制下，把磁带上的计算结果由相应的输出设备输出。
> - 联机输入输出是指输入输出操作在主机控制下进行。



##### 5. 比较单道与多道批处理系统的特点及优缺点

> - 单道批处理系统是最早出现的一种OS，它具有自动性、顺序性和单道性的特点。
> - 多道批处理系统具有调度性、无序性和多道性的特点。
> - 单道批处理系统是在解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾中形成的，旨在提高系统资源利用率和系统吞吐量，但是仍然不能很好的利用系统资源。
> - 多道批处理系统是对单道批处理系统的改进，其主要优点是资源利用率高，系统吞吐量达；缺点是平均周转时间长，无交互能力。



### 【进程管理】

##### 1. 试从动态性、并发性和独立性上比较进程和程序。

> - 动态性是进程最基本的特性，可变现为由创建而产生、由调度而执行、因得不到资源而阻塞、以及由撤销而消亡，因而进程有一定的生命期；而程序只是一组有序指令的集合，是静态实体。
> - 并发性是进程的重要特征，同时也是操作系统的重要特征。
>   - 引入进程的目的正是为了使进程能够并发执行。
>   - 而程序是不能并发执行的。
> - 独立性是指进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位。而对于未建立任何进程的程序，都不能作为一个独立的单位参与运行。



##### 2. PCB的主要存储内容是什么？为什么说PCB是进程存在的唯一标志？

> PCB是进程实体的一部分，是操作系统中最重要的记录型数据结构。
>
> PCB保存进程运行期间相关的数据，其中记录了操作系统所需的用于描述进程及控制进程运行所需的全部信息。主要包括：进程标识符PID、进程当前状态、进程控制信息、队列指针等。
>
> PCB的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，一个可以和其他进程并发执行的进程。
>
> 在进程的整个生命周期，系统总是通过PCB对进程进行控制的。也就是说，系统是根据进程的PCB感知进程存在的。所以说，PCB是进程存在的唯一标志。



##### 3. 引起进程创建的主要事件以及进程创建的过程？

> - 引起进程创建的事件
>   - 用户登录
>   - 作业调度
>   - 提供服务
>   - 应用请求
> - 进程创建的过程
>   - 操作系统发现请求创建新进程事件后，调用进程创建原语
>   - 申请空白PCB
>   - 为新进程分配资源
>   - 初始化进程控制块
>   - 将新进程控制块插入就绪队列



##### 4. 引起进程撤销的事件以及进程撤销的过程？

> - 引起进程撤销的事件
>   - 正常结束
>   - 异常结束
>   - 外界干预
> - 进程撤销的过程
>   - 操作系统调用进程终止原语
>   - 根据被终止进程的标志服，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。
>   - 若被终止进程正处于执行状态，应立即终止该进程的执行，并设置调度标志为真
>   - 若该进程还有子孙进程，还应将其所有子孙进程予以终止。将该进程所拥有的全部资源，归还给其父进程，或归还给系统。
>   - 将被终止进程的PCB从所在队列中移出



##### 5. 进程的两种通信方式？

> - 互斥
>   - 当一个进程进入临界区使用临界资源时，另一个进程必须等待，直到占用该临界资源的进程退出临界区，才允许新的进程访问该临界资源。
> - 同步
>   - 是指多个相互合作的进程在一些关键点上可能需要互相等待或交换信息。



##### 6. 从调度性、并发性、拥有资源及系统开销的角度，比较进程和线程？

> - 在引入线程的操作系统中，把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位。
> - 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可以并发执行，因而使操作系统具有更好的并发性。
> - 进程始终是拥有资源的一个独立单位，线程自己不拥有系统资源，但它可以访问其隶属进程的资源。
> - 在创建，撤销和切换进程方面，进程的开销远远大于线程的开销。



##### 7. 比较用户级线程和内核级线程？

> - 内核级线程是依赖于内核的，它存在于用户进程和系统进程中，它们的创建、撤销和切换都由内核实现。
> - 用户级线程仅存在于用户级中，它们的创建、撤销和切换不利用资源调用来实现，因而与内核无关，内核并不知道用户级线程的存在。
> - 内核级线程的调度和切换与进程十分相似，调度方式采用抢占式和非抢占式，调度算法采用时间轮转法和优先权算法等，当由线程调度选中一个线程后，再将处理器分配给它。而用户级线程通常发生在一个应用程序的诸线程之间，无需终端进入操作系统内核，切换规则也较简单，因而，用户级线程的切换速度较快。
> - 用户级线程调用系统调用和调度另一个进程执行时，内核把它们看作是整个进程的行为，内核级线程调用是以线程为单位，内核把系统调用看作是该线程的行为。



##### 8. 什么是死锁？产生死锁的原因？产生死锁的必要条件？

> 死锁是由进程之间因竞争资源或推进顺序不当导致的一种无法继续推进的状态。
>
> 产生死锁的原因：
>
> - 竞争资源
> - 进程推进顺序不当
>
> 死锁的四个必要条件：
>
> - 互斥条件
> - 不可剥夺条件
> - 请求和保持条件
> - 循环等待条件
>



##### 9. 如何预防死锁？

> - 破坏互斥条件
>   - 将临界资源改造为可共享使用的资源（如SPOOLing技术）
>   - 缺点：可行性不高，很多时候无法破坏互斥条件
> - 破坏不剥夺条件
>   - 申请的资源得不到满足时，立即释放拥有的所有资源
>   - 申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）
>   - 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿。
> - 破坏请求和保持条件
>   - 运行前分配好所有需要的资源，之后一直保持
>   - 缺点：资源利用率低；可能导致饥饿
> - 破坏循环等待条件
>   - 给资源编号，必须按编号从小到大的顺序申请资源
>   - 缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦



##### 10. 如何避免死锁？

> 银行家算法。



##### 11. 安全状态与不安全状态？

> 安全状态：如果存在一个由系统中所有进程构成的安全序列，则系统处于安全状态。安全状态一定不会发生死锁。
>
> 不安全状态：不存在一个安全序列。不安全状态可能发生死锁。



##### 12. 如何检测死锁？

> 资源分配图。



##### 13. 如何解除死锁?

> - 资源剥夺法
>   - 挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
> - 撤销进程法（终止进程法）
>   - 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。
>   - 这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，接近结束了，一旦被终止可谓功亏一篑，之后还得从头再来。
> - 进程回退法
>   - 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求操作系统要记录进程的历史信息，设置还原点。



##### 14. 什么是临界资源、死锁？若采用以下算法解决哲学家就餐问题，是否会导致死锁？为什么？

```c++
semaphore fork[5] = {1,1,1,1,1};
void main(){
  cobegin {
    philosopher(0);
    philosopher(1);
    philosopher(2);
    philosopher(3);
    philosopher(4);
  }coend
}

void philosopher(int i) {
  while(1) {
    thinking;
    if(i == 0) {
      P(fork[i]);
      P(fork[(i+1) % 5]);
    } else {
      P(fork[(i+1) % 5]);
      P(fork[i]);
    }
    
    eating;
    V(fork[i]);
    V(fork[(i+1) % 5]);
  }
}
```

> **临界资源**：必须互斥使用的资源，称为临界资源。
>
> **死锁**：多个进程因竞争资源或执行时顺序推进不当而导致处于永久堵塞的现象，如果无外力的作用，将永久保持这种状态。
>
> 该算法不会导致死锁。因为该算法破坏了产生死锁的四个必要条件之一：循环等待条件。该算法的中心思想是对每个临界资源进行编号，保证每个哲学家必须按照从小到大的次序依次申请资源，从而不会产生循环等待现象。



##### 15. 在哲学家就餐问题中，如果将先拿起左边筷子的哲学家称为左撇子，而将先拿起右边筷子的哲学家称为右撇子，在同时存在左撇子和右撇子的前提下，我们安排哲学家随意就座。请问是否可能产生死锁，为什么？

> 不可能产生死锁，因为破坏了产生死锁的四个必要条件之一：循环等待条件。
>
> 如果有循环等待，则所有的左边的科学家等右边的科学家放下筷子，每个科学家都获得了左边的筷子，而没有右边的筷子，与题意存在右撇子不符。同理，不存在另一种情况。而且不相邻的哲学家间无竞争资源的关系，所以，也不可能存在循环等待。



### 【内存管理】

##### 1. 程序的装入方式？分别适用于何种场合？

> 编译 - 链接 - 装入：
>
> - 由编译程序将用户源代码编译成若干目标模块
> - 再由链接程序将编译后形成的目标模块和所需的库函数链接在一起，组成一个装入模块
> - 再由装入程序将装入模块装入内存
>
> 三种装入方式：
>
> - 绝对装入：适用于单道程序环境
> - 可重定位装入（静态重定位）：适用于多道程序环境
> - 动态重定位装入：适用于多道程序环境



##### 2. 链接的三种方式？

> - 静态链接
>   - 是指事先进行链接形成一个完整的装入模块，以后不再拆开。
> - 装入时动态链接
>   - 是指目标模块在装入内存时，边装入边链接
> - 运行时动态链接
>   - 是将某些目标模块的链接推迟到执行时才进行



##### 3. 逻辑地址和物理地址？

> - 物理地址是物理存储器中存储单元的地址，一个物理地址与一个物理存储单元一一对应。所有物理地址组成物理地址空间。
> - 逻辑地址是指程序指令中地址部分出现的地址。
>   - 计算机系统采用多道程序设计技术之后，往往要在存储器内同时存放多个作业的程序，而这些程序在主存储器中的地址是不能预先知道的。
>   - 逻辑地址从0开始编号，用户按逻辑地址编写程序。
>   - 每个完整的程序都有独立的、从0开始且连续的逻辑地址空间。



##### 4. 在存储器管理中，什么是重定位？为什么要引入重定位技术？

> 因为源程序经过编译、链接产生的装入模块是从0开始编址的，地址都是相对起始地址的相对地址。在装入内存时，分配到的内存的起始地址一般不为0，所以，实际物理地址和装入模块中的相对地址不同。
>
> 是什么：
>
> - 装入内存时，将程序的逻辑地址转化为物理地址的过程。
>
> 为什么引入：
>
> - 为了在程序执行过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，引入了动态重定位。
>
> 如何实现：
>
> - 可在系统中增加一个重定位寄存器，用它来存放程序在内存中的起始地址，程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的，从而实现动态重定位。



##### 5. 何为覆盖技术？为何引入覆盖技术？

> 是什么：
>
> - 将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存。
>
> 为何引入：
>
> - 解决逻辑地址空间总和大于物理地址空间的矛盾。
>
> 特点：
>
> - 必须由程序员声明覆盖结构，由操作系统完成自动覆盖。对用户不透明，增加了编程负担。



##### 6. 何为交换技术？为何引入交换技术？

> 是什么：
>
> - 解决多道程序逻辑地址空间总和大于物理地址空间的矛盾。
> - 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存。
>
> 为何引入：
>
> - 能将内存中暂时不运行的进程或暂时不用的程序和数据换到外存上，以腾出足够的内存空间，把已具备运行条件的进程或进程所需的程序和数据换入内存，从而大大提高了内存的利用率。
>
> 特点：
>
> - 由操作系统实现，对程序透明，无需程序员干预。



##### 7. 操作系统中什么是虚拟存储器？为什么要引入虚拟存储器？

> 是什么：
>
> - 虚拟存储器是指具有请求调入和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行的速度接近于内存速度。
>
> 为何引入：
>
> - 计算机操作系统引入和使用虚拟存储技术的主要目的是提高系统的内存利用率和系统吞吐量。
>
> 特征：
>
> - 离散性（最本质）
> - 多次性
> - 对换性
> - 虚拟性



##### 8. 局部性原理？

> - 时间局部性
>   - 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；
>   - 如果某个数据被访问过，不久之后该数据很可能再次被访问。
> - 空间局部性
>   - 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。



##### 9. 如何实现页式虚拟存储器？

> 页式虚拟存储器是指在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的。
>
> - 它允许只装入部分页面。以后再通过调页和页面置换功能，把即将运行的页面调入内存，同时把暂时不运行的页面换到外存上。
> - 实现请求调页和置换功能，系统还要提供必要的硬件和软件支持。



##### 10. 请求分页管理方式的页表项？

> - 页号
> - 内存块号
> - 状态位
>   - 表示该页是否调入内存
> - 访问字段
>   - 记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出时参考
> - 修改位
>   - 表示该页在调入内存后是否被修改过
> - 外存地址
>   - 指出该页在外存上的地址，通常是物理块号，供调入该页时使用



##### 11. 请求分页管理方式中调入页面的过程

> - 在进程地址变换时，首先去检索快表，试图从中找出所要访问的页。若找到，则：
>   - 修改页表项中的访问位
>   - 对于写指令，还需将修改位置为1
>   - 然后利用页表项中给出的物理块号和页内地址，形成物理地址
> - 如果在快表中未找到该页的页表项，则应再从内存中去查找页表，再从找到的页表项中的状态位来判断该页是否已调入内存
>   - 如果该页已调入内存，应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项，再写入该页的页表项。
> - 如果该页尚未调入内存，则产生缺页中断，请求操作系统从外存中把该页调入内存。
> - 外存分为文件区和对换区，
>   - 若系统有足够的对换区空间，可在进程运行前，将与该进程有关的文件拷贝到对换区，需要时从对换区调入。
>   - 若系统缺少足够的对换区空间，则
>     - 凡是不会被修改的文件，可直接从文件区调入，换出时不必写入外存。
>     - 但对于可能被修改的部分，在将它们换出时，需要调到对换区，以后需要时再从对换区调入。



##### 12. 在分页存储管理系统中，页表的主要作用是什么？现代大多数计算机系统都支持非常大的逻辑空间，这给页表的设计带来了什么样的新问题，应如何解决？

> 页表的主要作用是用来记录进程中的每个页面和对应的页框的信息。
>
> 非常大的逻辑地址空间会导致进程的页表增大，装入连续的地址空间难度大。可以通过多级页表机制解决这个问题。对页表进行分页，将页表离散的存储，并为离散的页表再建立页表。也可以引入虚拟页式存储，提高内存的利用率。



##### 13. 阐述基本分页存储管理和请求分页存储管理的异同之处。

> 在基本分页存储管理系统中，系统将每个程序按固定的大小分成若干页，每页对应一个物理块号。程序的所有页面都被装到内存当中。
>
> 请求分页存储管理在分页系统的基础上，增加了请求调页功能和页面置换功能。
>
> - 在请求分页存储管理系统中，程序仍被分成若干页，但仅仅装入程序运行所必须的页面。
> - 当需要某个页面时，再请求从外部调入。
> - 如果没有空闲的空间，则利用置换技术进行页面的淘汰和置换。



##### 14. 抖动现象?产生原因和解决方法？

> 是什么：
>
> - 指页面置换过于频繁，刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又被换粗。造成程序执行效率低下。
>
> 产生原因：
>
> - 页面置换算法使用不当
> - 内存过小
> - 并发程序过多
> - 工作集大小选择不当
>
> 解决方法：
>
> - 采取局部替换策略
> - 引入工作集算法
> - 挂起或撤销部分进程
> - 增加物理内存



##### 15. 工作集原理？为何引入工作集？

> 为何引入：
>
> - 引入工作集是为了逼近最佳置换算法。
>   - 最佳置换算法的基础是未来页面的使用情况，但是，获得未来页面精确的使用情况是不现实的，因而，只能利用页面的历史记录作为预测未来页面需求的依据。
>   - 然而考虑所有历史记录开销过大，所以工作集模型将历史记录限制在一个“窗口”之内，即不考虑所有历史记录，而只考虑距目前最近的定长的历史记录，丢弃更久远的换页数据，其依据仍然是局部性原理。
>
> 原理：
>
> - 每个进程在给定时刻t，都设置换页记录W(t, k)，即在时间间隔（t-k, t) 之间的页面使用记录，k是系统指定的常量。
>   - 如果有换页需求，则工作集中的页面不作置换，即置换的页面是工作集之前使用的页面。
>   - 进程只有在当前工作集中的页面全部位于内存时才执行。



### 【文件管理】

##### 1. 文件的逻辑结构

> 文件的逻辑结构是指用户所看到的文件组织形式。
>
> - 无结构文件（流式文件）：文件内部的数据是一系列二进制流或字符流组成。
> - 有结构文件（记录式文件）：由一组相似的记录组成。每条记录又由若干个数据项组成。
>   - 顺序文件：文件中的记录一个接一个顺序排列。在物理上是顺序存储的。有一个可以唯一标识记录的数据项，称为键，记录按键值的约定次序组织。
>     - 优点：实现简单
>     - 缺点：增加、删除麻烦
>   - 索引文件：针对主文件中的记录按需要的数据项（一个或几个）键索引，这些索引组成的索引文件称为索引表，索引表本身是顺序文件。
>   - 索引顺序文件：将顺序文件分成等长的块，并为这些块建立索引，使这些等长的块不必顺序存放。每块中的记录按关键字顺序组织。



##### 2. 文件控制块（FCB）和索引结点（i-node）

> 文件控制块（FCB）：是文件系统管理文件所必须的各种控制信息组成的数据结构，它是文件存在的唯一标志。
>
> - 四个组成部分：
>   - 基本信息：文件名、文件类型等
>   - 保护信息：访问权限等
>   - 位置信息：存储位置、文件长度等
>   - 使用信息：时间信息、最迟使用者等
> - 文件控制块的集合称为文件目录，文件目录也被组织成文件，称为目录文件。
> - 文件目录的结构形式有单级目录结构、两级目录结构、树形目录结构、图形目录结构。
>
> 索引结构（i-node）：是文件描述符的一种实现。系统中的每个文件或目录都对应一个文件描述符。
>
> - 组成部分
>   - 文件的属主
>   - 文件类型
>   - 文件保护信息
>   - 文件的逻辑记录与磁盘块的对应
>   - 创建时间、最后使用时间、最后修改时间
>   - 共享该文件的目录数
>
> 所有索引结点一般都存储在磁盘上一个特定表中，称为索引表。目录中只存放文件名以及指向该文件索引结点的指针。



##### 3. 文件目录结构

> - 一级目录结构
>   - 文件系统中只有一个目录文件，每一表项是一个文件控制块，对应一个文件。
>   - 优点：易于实现、管理简单
>   - 缺点：系统中文件数增多时，查找时间长；且不能重名。
> - 两级目录结构
>   - 文件系统将目录分为两级。
>     - 第一级目录称为主目录，记录用户名及相应用户目录的存储位置。
>     - 第二级目录时用户目录，以顺序表形式存放该用户文件的文件控制块。
>   - 优点：不同用户之间的文件可以重名；对文件的共享和保护也比一级目录结构好。
>   - 缺点：缺乏灵活性，用户不能对自己的文件进行分类。
> - 树形目录结构
>   - 将二级目录结构的级数增加，就形成树形目录结构。第一级目录常用作系统目录，称为根目录。
>   - 在多级目录结构中，从根出发到任何一个叶结点有且只有一条路径，该路径的全部节点名构成一个全部路径名，称为绝对路径。
>   - 为方便查找，还可以设置当前目录。
>   - 优点：方便对文件进行分类，层次结构清晰，能更有效地进行文件的管理和保护。
>   - 缺点：不便于实现文件的共享。
> - 图形目录结构
>   - 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。
>   - 优点：可以更方便的的实现文件共享。



##### 4. 文件物理结构及其优缺点

> 文件物理结构是指一个文件在外存上的存储组织形式，主要有连续结构、链接结构和索引结构三种。
>
> - 连续结构（顺序分配）
>   - 最简单、速度最快的分配方式。在文件建立时预先分配一个连续的物理块集，按照逻辑文件中的记录顺序，依次顺序存储到物理块中。只需要直到文件在文件存储设备上的起始位置和文件长度，就能进行存取。
>   - 优点：可以随机访问磁盘，访问速度比较快。
>   - 缺点：必须要求有连续的存储空间，容易产生碎片，且磁盘利用率低，不利于文件的增长扩充。
> - 链接结构
>   - 按单个物理块逐个分配。每个物理块中设有一个指针，指向下一个物理块的地址。在建立链接文件时，不需要指定文件的长度，在文件说明信息中，只需要指出该文件的第一个物理块块号。
>   - 优点：不要求连续的存储空间，磁盘利用率高，有利于文件的增长扩充。
>   - 缺点：适合顺序访问，不适合随机访问；文件的数据块之间是通过指针进行链接，指针占用了一定空间。
> - 索引结构
>   - 系统为每个文件建立一张索引表，索引表中每一表项指出文件所在的逻辑块号和与之对应的物理块号。
>   - 对一些大的文件，索引表的大小会超过一个物理块，就会发生索引表的分配问题。因此可以采用多级索引。
>   - 优点：既支持顺序访问，也支持随机访问，并且查找效率高；便于文件的删除。
>   - 缺点：索引表占用了一定的存储空间。



##### 5. 何谓文件的混合索引结构？其主要优点是什么？

> 混合索引是指多种索引分配方式相结合的分配方式。如系统既采用直接地址，又采用单级和多级索引分配方式。
>
> 优点是：可以随机访问，易于文件的增删。



##### 6. 文件存储空间管理及其优缺点？

> - 空闲表法
>   - 为所有连续空闲区单独建立一个空闲表。表项的内容包括第一个空闲块号、物理块号和空闲块数目。
>   - 当某用户请求分配存储空间时，系统回收该文件所占用的空间，直到找到一个满足要求的空闲文件为止。当用户撤销一个文件时，系统回收该文件所占用的空间。
>   - 优点：
>   - 缺点：
> - 空闲链表法
>   - 将文件存储设备上的所有空闲块链接在一起，形成一条空闲块链，并设置一个头指针指向空闲块链的第一个物理块。
>   - 当用户建立文件时，就按需要从链首依次取下一个或几个空闲块分配给文件。当撤销文件时，回收其存储空间，并将回收的空闲块依次链入空闲块链中。
>   - 优点：
>   - 缺点：
> - 位示图法
>   - 为文件存储器建立一张位示图，每一个二进制都对应一个物理块，若某位为1，表示对应的物理块已分配；若为0，表示对应的物理块空闲。
>   - 当请求分配存储空间时，系统顺序扫描位示图并按需要从中找出一组值为0的二进制位，再经过简单的换算就可以得到相应的盘块号，然后将这些位变为1。当撤销时，只需要将位示图的相应位置为0。
>   - 优点：很容易找到一个连续的空闲块。
>   - 缺点：整个磁盘的位示图文件比较大，在磁盘空闲块较少时，搜索空闲块浪费一些时间。
> - 成组链接法
>   - 适用于大型文件系统。将一个文件的所有空闲块按每组100块分成若干组，把每一组的盘块数目和该组的所有盘块号记入到前一组的第一个盘块中，第一组的盘块数目和第一组的所有盘块号记入到超级块中。



##### 7. 文件共享（软链接和硬链接）

> - 硬链接（基于索引结点的共享方式）
>   - 不同目录下使用相同索引结点，在索引结点中再增加一个计数值来统计指向该索引结点的目录项个数。只有计数值为1时才可删除该索引结点，若计数值大于1，则删除时把计数值减1即可。增加共享时计数值加1。
>   - 在硬链接中，目录项中只有文件名，指向的是共同的索引结点，索引结点再指向文件，所以一个文件修改索引结点，其他所有文件名的索引结点都被修改了。
>   - 优点：实现文件的异名共享。
>   - 缺点：当文件被多个用户共享时，文件拥有者不能删除文件。
> - 软链接（基于符号链的共享方式）
>   - 相当于把共享文件的路径副本复制过来，并且只有在文件试图去访问时才会更新其路径副本。
>   - 优点：解决了文件拥有者不能删除共享了的文件的问题。
>   - 缺点：当其他用户要访问共享文件时，需要逐层查找目录，开销较大。
>
> 二者区别：
>
> - 只要有一个硬链接存在，物理文件就不会被清除。硬链接和源文件是平等的，只删除一个不能使文件真正被删除；
> - 如果软链接创建时指定的那个目录被删除，则无法访问物理文件。软链接是附属于原文件的，删除、更改原文件路径后软链接会失效。



##### 8. 磁盘的访问时间

> - 寻道时间：磁头移动到指定磁道的时间
> - 延迟时间：等待所需扇区转到磁头下的时间
> - 传输时间：读写扇区的时间



### 【外设管理】

##### 1. I/O控制方式

> （1）程序控制方式
>
> - 处理器启动数据传输，然后等设备完成。
> - I/O操作开始之前、完成之后都需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。
> - 每次读/写一个字。
> - 数据流向
>   - 读操作：I/O设备 - CPU - 内存
>   - 写操作：内存 - CPU - I/O设备
> - 优点：实现简单
> - 缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。
>
> （2）中断驱动方式
>
> - 进程启动数据传输后，处理机先切换到别的进程执行。当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。
> - 每次I/O操作开始之前、完成之后需要CPU介入。等待I/O完成的过程中CPU可以切换到别的进程执行。
> - 每次读/写一个字。
> - 数据流向
>   - 读操作：I/O设备 - CPU - 内存
>   - 写操作：内存 - CPU - I/O设备
> - 优点：CPU不再需要不停地轮询，CPU和I/O设备可以并行工作，CPU利用率得到明显提升。
> - 缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗CPU更多的时间。
>
> （3）DMA方式
>
> - 外部设备和主存之间开辟直接的数据交换通路。DMA控制器包括控制状态寄存器、数据缓冲寄存器、传输字节计数器和主存地址寄存器等。CPU指明此次要进行的操作，并说明要读入多少数据、数据存放在什么位置、数据在磁盘上的地址，控制器会根据CPU提出的要求完成数据的读/写工作，整块数据传输完成后，才向CPU发出中断信号。
> - 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。
> - 每次读/写一个或多个块。
> - 数据流向
>   - 读操作：I/O设备 - 内存
>   - 写操作：内存 - I/O设备
> - 优点：数据传输以块为单位，CPU介入频率进一步降低。CPU与I/O设备并行性得到提升。
> - 缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。
>
> （4）通道方式
>
> - 通道可以执行一系列通道指令。CPU向通道发出I/O指令并给以相应参数，通道执行内存中的通道程序，执行完成后，向CPU发出中断信号，之后CPU对中断进行处理。
> - 通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。
> - 每次读/写一组数据块。
> - 数据流向
>   - 读操作：I/O设备 - 内存
>   - 写操作：内存 - I/O设备
> - 优点：CPU、通道、I/O设备可并行工作，资源利用率很高。
> - 缺点：实现复杂，需要专门的通道硬件支持。



##### 2. 什么是DMA方式？它与中断方式的主要区别是什么？

> DMA是直接存储器存取。DMA传输将数据从一个地址空间复制到另一个地址空间。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实行和完成。在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。
>
> 它与中断方式的主要区别在于，DMA方式只需要CPU在开始和完成传输时进行干预，其他时候不需要CPU干预。中断驱动方式在每个数据需要传输时中断CPU，而DMA方式则是在做要求传送的一批数据全部传送结束时才中断CPU。中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA方式则是在DMA控制器的控制下完成的。



##### 3. I/O软件层次结构

> - 用户层软件
>   - 实现与用户交互的接口，向上提供方便易用的库函数
> - 设备独立性软件
>   - 向上层提供统一的调用接口
>   - 设备保护
>   - 差错处理
>   - 设备的分配与回收
>   - 数据缓冲区管理
>   - 建立逻辑设备名到物理设备名的映射关系
> - 设备驱动程序
>   - 设置设备寄存器、检查设备状态
> - 中断处理程序
>   - 进行中断处理



##### 3. 什么是SPOOLing技术？组成部分和原理？

> 是什么：
>
> - SPOOLING技术的要点是将物理设备虚拟化，可以将低速的独占设备虚拟化成一种共享设备，而且使一台物理设备对应于若干台虚拟的同类设备。在多道程序下，利用其中一道或两道模拟脱机输入/输出中的外围控制机的功能，以达到假脱机的目的。可以把独占的设备变成共享的虚拟设备，从而提高独占设备的利用率。
>
> 组成部分：
>
> - 输入井和输出井：磁盘上开辟的两大存储空间。
>   - 输入井：模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据。
>   - 输出井：模拟脱机输出时的磁盘设备，用于暂存用户程序的输出数据。
> - 输入缓冲区和输出缓冲区：为了缓和CPU和磁盘之间速度不匹配的矛盾，在内存中开辟了两个缓冲区
>   - 输入缓冲区：用于暂存由输入设备送来的数据，以后再传送到输入井
>   - 输出缓冲区：用于暂存由输出井送来的数据，然后再传送到输出设备。
> - 输入进程和输出进程：
>   - 输入进程：模拟脱机输入时的外围控制机，将用户要求的数据从输入设备通过输入缓冲区再传递到输出井。当需要输入数据时，CPU直接将数据从输入井读入内存。
>   - 输出进程：模拟脱机输出时的外围控制机，将用户要求输出的数据先从内存送到输出井，等输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。
>
> 特点：
>
> - 提高了I/O速度
> - 设备并没有分配给任何进程
> - 实现了虚拟设备功能



##### 4. 什么是设备的独立性，应该如何实现？

> 是什么：
>
> - 设备独立性是指应用程序独立于具体的物理设备即设备的无关性。
>
> 如何实现：
>
> - 为了实现设备独立性，需要在设备驱动程序上设置一层设备独立性软件，用来执行所有 I/O 设备的公用操作，并向用户层软件提供统一接口。
> - 关键是系统中必须设置一张逻辑设备表（LUT）用来进行逻辑设备到物理设备的映射，其中每个表目中包含逻辑设备名、物理设备名和设备驱动程序入口地址；
> - 当应用程序用逻辑设备名请求分配 I/O 设备时，系统必须为它分配相应的物理设备，并在LUT中建立一个表目，以后进程利用该逻辑设备名请求 I/O 操作时，便可从 LUT 中得到物理设备和驱动程序入口地址。



##### 5. 缓冲与缓冲区

> 是什么：
>
> - 缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以用内存作为缓冲区。
>
> 为何引入（作用）：
>
> - 缓和CPU与I/O设备之间速度不匹配的矛盾
> - 减少对CPU的中断频率，放宽对CPU中断相应时间的限制
> - 解决数据粒度不匹配的问题
> - 提高CPU与I/O设备之间的并行性
>
> 分类：
>
> - 单缓冲：在CPU和外设之间设置了一个缓冲区，当有数据交换时，先把数据发往缓冲区，再从缓冲区读数据。
> - 双缓冲：具有两个缓冲，当一个进程正往一个缓冲区读数据的时候，操作系统可能正在读或写另一个缓冲区。
> - 循环缓冲：多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区。具有多个缓冲区的组合，它更加能够缓和CPU和外设之间速度不匹配的问题。
> - 缓冲池：三个队列（空缓冲队列、输入队列、输出队列）、四种工作缓冲（用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区）


