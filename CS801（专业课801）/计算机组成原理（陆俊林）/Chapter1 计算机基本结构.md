# 第一章 计算机基本结构（Basic Components of a Computer）

[TOC]

## 第一节 电子计算机的兴起

### “现代电子计算机之父” —— 冯·诺依曼

<img src="1-1.jpg" />

> 冯·诺依曼在二战期间参与原子弹的研制工作，遇到一个很大的困难，是运算量太庞大。于是他就致力于寻找具有强大运算能力的设备。



###### “二战”对计算能力的需求

<img src="1-2.jpg" />



### 电子计算机时代的到来

#### ENIAC（宾夕法尼亚大学）—— 世界上第一台通用电子计算机

<img src="1-3.jpg" />

<img src="1-4.jpg" />

> 它实际上是在二战结束后才完成的， 并没有为二战的火炮图做出什么贡献。
>
> 但它在之后的弹道计算、原子弹研究、气象预报等很多方面发挥了重要作用。

> 它是**世界上第一台通用电子计算机**，因为在它之前已经有人设计出了**电子计算机**。



#### ABC（美国艾奥瓦州立大学） —— 阿塔纳索夫-贝里计算机

<img src="1-5.jpg" />

> ENIAC的设计借鉴了ABC。
>
> 很多年后，因为ENIAC的设计思想来源于ABC，所以ENIAC的专利被判无效。



#### 冯·诺依曼对ENIAC的分析

###### “存储程序”的概念

> ENIAC的开关定位和转插线只不过代表着一些数字信息，完全可以像受程序管理的数据一样，存放于主存储器中。



###### 冯·诺依曼和《关于EDVAC的报告草案》

<img src="1-6.jpg" />



#### EDVAC —— 存储程序式计算机（冯·诺依曼结构计算机）

###### 主要特点

> - 实现“存储程序”概念，大幅提升了任务效率
> - 质量和数据采用二进制，极大简化了逻辑线路
> - 由五个基本部分组成
>   - 运算器
>   - 控制器
>   - 存储器
>   - 输入设备
>   - 输出设备

<img src="1-7.jpg" />

> 但EDVAC不是世界上第一台冯·诺依曼结构计算机，因为研究团体解散等问题，它被EDSAC抢了先。



#### EDSAC —— 第一台实用的存储程序式计算机

###### 五个组成部分

> - **运算器**和**控制器**：电子管
> - **存储器**：水银延迟线
> - **输入设备**：从穿孔纸带输入
> - **输出设备**：电传打印机

<img src="1-8.jpg" />



#### UNIVAC —— 开启了商用计算机的时代

<img src="1-9.jpg" />

###### 1952年 —— 统计总统选票

<img src="1-10.jpg" />



#### IBM701

<img src="1-11.jpg" />

> **UNIVAC** 开启了商用计算机的时代。



#### 众多著名计算机

###### IBM S/360 —— 1964年

<img src="1-12.jpg" />



###### CDC6600（第一台超级计算机） —— 1964年

<img src="1-13.jpg" />



###### PDP-8 —— 1965年（小型计算机的经典）

<img src="1-14.jpg" />



###### Altair8800 —— 1975年（第一台微型计算机）

<img src="1-15.jpg" />



###### Apple II —— 1977年（微型计算机经典）

<img src="1-16.jpg" />



###### IBM PC 5150 —— 1981年（微型计算机经典）

<img src="1-17.jpg" />



###### IBM zEC12 —— 2012年（当前最先进的大型计算机之一）

<img src="1-18.jpg" />



###### 天河二号 —— 2013年（当前最快的超级计算机）

<img src="1-19.jpg" />



## 第二节 冯·诺依曼结构的要点

### 《关于EDVAC的报告草案》

> 该报告所描述的计算机结构，即为 **“冯·诺依曼计算机结构”** ， 简称 **“冯·诺依曼结构”**。

###### 两个重要思想

> - 存储程序（而不是开关连线）
> - 二进制（而不是十进制）

###### 明确了计算机的五个部分

> - 运算器
> - 控制器
> - 存储器
> - 输入设备
> - 输出设备

<img src="1-2-1.jpg" />



### Intel 4004 —— 世界上第一个商业微处理器

<img src="1-2-2.jpg" />

<img src="1-2-3.jpg" />

<img src="1-2-4.jpg" />



### 冯·诺依曼结构的要点

#### 计算机的五大组成部分

1. 运算器 CA - Central Arithmetical
2. 控制器 CC - Central Control
3. 存储器 M - Memory
4. 输入设备 I - Input
5. 输出设备 O - Output

<img src="1-2-5.jpg" />

> - 计算机应由**运算器**、**控制器**、**存储器**、**输入设备**和**输出设备**共5个部分组成
> - 数据和程序均以二进制代码形式不加区别地存放在存储器中，存放位置由存储器的地址指定
> - 计算机在工作时能够自动地从存储器中取出指令加以执行
> - ......



#### 冯·诺依曼结构的核心 —— 运算器、控制器、存储器

<img src="1-2-6.jpg" />

###### 现代个人计算机中的CPU和主存

<img src="1-2-7.jpg" />

###### 主存的组织形式

<img src="1-2-8.jpg" />



#### 冯·诺依曼计算机的类比

<img src="1-2-9.jpg" />

> 将**程序**和**数据**不加区分地存储在**存储器**当中。



#### :star:存储程序的概念总结

> - 计算机中所需要的程序和数据通过**输入设备**进入了**存储器**
> - **控制器**发出地址给**存储器**，获得程序当中的对应的指令，还可以得到相应的数据
> - **控制器**发命令给**运算器**，指挥**运算器**对数据进行相应的运算
> - **运算器**返回一些运算的状态，比如是否正确完成等等，最后还会将运算的结构存储到**存储器**中
> - 最后通过**输出设备**将运算结果输出到计算机外部的某些存储介质上

<img src="1-2-10.jpg" />



## 第三节 冯·诺依曼结构的小故事

### 关于计算机运行过程的类比

冯·诺依曼结构的计算机就好比一个餐馆：

| 仓库                   | 主存               |
| ---------------------- | ------------------ |
| 仓库中的货架           | 主存当中的存储单元 |
| 为货架的每一格编上序号 | 主存当中的地址     |
| 货架上存放的物品       | 存储单元中的内容   |
| 要执行的任务单         | 指令               |
| 做菜所用的原料         | 数据               |

| 厨房                 | CPU           |
| -------------------- | ------------- |
| 大厨                 | 控制器        |
| 厨具                 | 运算器        |
| 下一张任务单的位置   | 程序计数器 PC |
| 放置当前任务单的位置 | 指令寄存器 IR |
| 放食物的盘子         | 通用寄存器    |

<img src="1-3-1.jpg" />



### 执行指令：计算机运转的核心内容

#### 计算机执行一条指令的主要步骤

- 第一步：取指（Fetch）
- 第二步：译码（Decode）
- 第三步：执行（Execute）
- 第四步：回写（Write-back）



#### 第一步：取指（取任务单）

> 厨师第一步要做的事情就是查看下一张任务单的位置在哪儿，我要去取这张任务单了，一查，发现是1。
>
> 向主存发出请求，我需要第1格的物品。（他并不知道第1格存放的是什么，他只是根据这里的编号，向主存发出申请）
>
> 主存并不简单是一些货架，它还是要有一些**控制逻辑**。那么这里控制逻辑就会响应控制器的请求，找到第1格的物品并送回。
>
> 厨师收到任务单了，就把它放在身边存放当前任务单的位置。
>
> 这就完成了第一步，取任务单。
>
> 取回后更新下张任务单的位置。

<img src="1-3-2.jpg" />

<img src="1-3-3.jpg" />



#### 第二步：译码（分析任务）

> 对厨师来说，就是分析刚才拿到的任务单。
>
> 任务单上说明了这项任务所需要的方法、所需要的原料、成果存放在某个地方。
>
> **控制器**就把它转换成若干组的控制信号。

<img src="1-3-4.jpg" />



#### 第三步：执行

> 向主存发出请求，说我需要第6格的物品。
>
> 主存会响应，把第6格的物品送过来。
>
> 由于这一次是取运算所需要的操作数，所以返回的物品呢，控制器就会把它放到运算器的其中一个入口。
>
> 然后第二步是取这个运算的第二个操作数。
>
> 第三步是执行这项运算，控制器会给出对应的运算信号给运算器让它执行对应的运算。
>
> 运算完成了，运算结果也产生了，执行阶段就到此结束了。

<img src="1-3-5.jpg" />



#### 第四步：回写（保存结果）

> 运算结果还放在运算器的输出端口上，我们必须要把它转移。
>
> 根据这条指令的要求，运算的结果应该是存放到A号的通用寄存器里。
>
> 我们在最后一步回写，也就是保存结果的时候呢，用控制器把这个结果传送到A号的通用寄存器当中。
>
> 这样就完成了执行指令的全部过程。

<img src="1-3-6.jpg" />



### 计算机执行指令的过程

<img src="1-3-7.jpg" />



## 第四节 计算机结构的简化模型

<img src="1-4-1.jpg" />

> 对照冯·诺依曼结构的餐馆，构造出计算机结构的简化模型（模型机）。

<img src="1-4-2.jpg" />



### 模型机的存储器

#### 编址方式

> 在设计计算机时要确定存储器的**编址方式**，如果存储器按字节编址，那每一个存储单元就能够存放8位的二进制数。

#### 组成部件

##### 地址总线

> 而且每个存储单元的地址是唯一的。CPU要想访问某个存储单元，必须通过地址总线给出相应的地址。

> 如果地址总线宽度为 n，则CPU能管理的存储单元最多为 $2^n$ 个。

##### MAR

> MAR（Memory Address Register, 存储器地址寄存器）
>
> CPU发来的地址，将会存放在**存储器地址寄存器**中。

##### 数据总线

> CPU所要读写的数据则会通过数据总线传送。
>
> 数据总线宽度一般为存储单元位宽的整数倍。

##### MDR

> MDR（Memory Data Register，存储器数据寄存器）
>
> 对应的数据则放在被称为存储器数据寄存器的结构中。

##### 控制总线

> 控制总线与存储器当中的控制逻辑相连，用于接收来自CPU的读写信号，或者向CPU反馈传输已经完成的信号。

<img src="1-4-3.jpg" />



### 模型机的CPU - 控制器

#### 功能

> 控制器用于控制计算机各部件完成取指令、分析指令和执行指令等功能。

#### 主要组成部分

> - 指令寄存器 IR（Instruction Register）
> - 程序计数器 PC（Program Counter）
> - 存储器地址寄存器 MAR（Memory Address Register）
> - 存储器数据寄存器 MDR（Memory Data Register）
> - 指令译码部件
> - 控制电路

<img src="1-4-4.jpg" />

##### 指令寄存器 IR

> 用于存放正在执行或者即将执行的指令。
>
> 这个指令是从存储器中取来的，暂时存放在这个寄存器里。

##### 程序计数器 PC

> 用于存放下一条指令的存储单元地址。
>
> 具有自动增量计数的功能。

##### 存储器地址寄存器 MAR

> 用于存放存储单元的地址。

##### 存储器数据寄存器 MDR

> 用于存放对存储单元读/写的数据。

<img src="1-4-5.jpg" />

##### 指令译码

> 对IR中的指令进行译码，以确定IR中存放的是哪一条指令。

##### 控制电路

> 当确定了是哪一条指令之后，控制电路就可以产生控制信号，在时序脉冲的同步下控制各个部件的动作。

<img src="1-4-6.jpg" />



### 模型机的CPU - 运算器

#### 功能

> 运算器用于算术运算和逻辑运算
>
> - 常见算术运算
>   - 加、减、乘、除等
> - 常见逻辑运算
>   - 非、与、或等

##### ALU（算术逻辑单元）

> 核心部件ALU用于完成算术运算和逻辑运算。
>
> ALU对X、Y中的数据进行运算，将结果送到Z。
>
> X、Y、Z作为ALU的数据暂存器，可视为ALU的一部分。
>
> 寄存器F 用于存放运算结果的状态（零/正负/进位/溢出）

##### 通用寄存器

> n个通用寄存器，用于临时存放数据。
>
> 数据可能来自存储器，也可能来自其他通用寄存器或ALU的输出。

<img src="1-4-7.jpg" />



### CPU的内部总线

> 内部总线用于在CPU内部各个部件之间传递数据。

#### 举例

> 将数据从R0 传送到 X（可能是为下一次运算进行准备）

> 从R0 传送到X，我们可以理解为在控制电路的控制下，将R0的出水管打开，再将X的入水管打开，与此同时，将其他部件的出水管和入水管都关闭。
>
> 这样R0 所保存的数据就像水流一样经过了内部总线，流到了X当中。
>
> 那么经过一段时间之后，X中保留的数，就跟R0中保存的数一样了。

<img src="1-4-8.jpg" />



## 第五节 计算机执行指令的过程

### 执行指令的示例

<img src="1-5-1.jpg" />



### 在模型机上的执行过程

> 假设模型机的当前状态已经有了一些初始值。
>
> CPU里的 R0 所保存的值是 00000011，即十进制 3
>
> 存储单元中地址为 6 的单元所保存的数是 00000010，即十进制 2
>
> 所要做的就是把地址为 6 的存储单元的数与 R0 中的数相加，再放到 R0 中

<img src="1-5-2.jpg" />

> PC 中所保存的值是 0001
>
> 对应存储器中 0001 地址所保存的内容 10101010，即为当前所要执行的指令

#### 第一步：取指

##### 主要功能

> 1. **控制器**将指令的地址送往**存储器**
> 2. **存储器**按给定的地址读出指令内容，送回**控制器**

##### 详细步骤

> 控制器会发出控制信号，将 PC 的内容通过控制总线传送到 MAR 

<img src="1-5-3.jpg" />

> MAR 将这一地址送到地址总线上
>
> 与此同时，控制电路会在控制总线上发出相应的控制信号，代表这次访问存储器的操作是要读数据

<img src="1-5-4.jpg" />

> 这样存储器的 MAR 就会收到地址总线上传过来的地址，并把它保存下来
>
> 存储器中的控制逻辑也会收到控制总线中传过来的控制信号，得知这一次访存操作是一次读操作

<img src="1-5-5.jpg" />

> 这样存储器通过地址译码器，就可以查到存储单元 0001 的内容
>
> 送到 MDR 寄存器中

<img src="1-5-6.jpg" />

> 存储器的控制逻辑会通过控制总线向CPU反馈，当前的传输已经准备好了
>
> 同时，MDR 中的内容也会送到数据总线上

<img src="1-5-7.jpg" />

> 随后，CPU中的控制电路检测到来自控制总线的 Ready 信号，就知道当前数据总线上已经准备好了数据
>
> 因此，CPU中的 MDR 就会将当前数据总线上的数值保存下来
>
> 这就获得了我们所要取的指令

<img src="1-5-8.jpg" />

> MDR 中的内容还需要传送到指令寄存器IR中

<img src="1-5-9.jpg" />

> 将PC更新为下一条指令所需要访问的地址

<img src="1-5-10.jpg" />



#### 第二步：译码

##### 主要功能

> 1. 控制器分析指令的操作性质
> 2. 控制器向有关部件发出指令所需的控制信号

##### 详细步骤

> 当前的指令寄存器IR 中的内容会送到指令译码部件中进行译码

<img src="1-5-11.jpg" />

> 指令译码部件根据指令编码，很快会发现这是一条加法指令
>
> 控制电路会据此产生对应的控制信号发到相关部件中

<img src="1-5-12.jpg"  />



#### 第三步：执行

##### 主要功能

> 1. 控制器从通用寄存器或存储器取出操作数
> 2. 控制器命令运算器对操作数进行指令规定的运算

##### 详细步骤

> 首先，根据这条指令，我们会发现还需要去取操作数
>
> 其中一个操作数在存储器中，因此，在MAR中放置要访问的存储器的地址 0110，即十进制的 6

<img src="1-5-13.jpg" />

> 随后的过程类似取指阶段的操作
>
> CPU的 MAR 将地址发到地址总线，同时控制电路在控制总线上发出读操作的控制信号
>
> 存储器的 MAR 和控制逻辑会接收到相应的信号，然后查找到对应的地址
>
> 查找的地址是 0110，对应的内容会送到 MDR 寄存器
>
> 控制逻辑会向CPU反馈当前数据已经准备好了的信号
>
> MDR 的内容也会被放置到数据总线上

<img src="1-5-14.jpg" />

> CPU会接收数据并保存在MDR当中

<img src="1-5-15.jpg" />

> 因为这个数据要进行加法运算，所以控制器会进一步将MDR中的数据传送到ALU的输入，即暂存到Y寄存器中

<img src="1-5-16.jpg" />

> 另一个操作数在R0中，因此，控制器还会将R0中的数据传送到ALU的另一个输入端，即寄存器X中

<img src="1-5-17.jpg" />

> 在控制电路的控制下，ALU就会进行运算，将X和Y中的内容执行加法，并计算出结果

<img src="1-5-18.jpg" />



#### 第四步：回写

##### 主要功能

> 1. 将运算结果写入通用寄存器或存储器

##### 详细步骤

> 现在运算结果还在ALU的输出端，也就是Z寄存器中
>
> 控制电路会给出相应的控制信号，将Z寄存器中的内容传送到R0中
>
> R0目前的内容是之前的原操作数，随后会被新的结果所覆盖

<img src="1-5-19.jpg" />



## 第六节 计算机输入和输出

### 冯·诺依曼计算机的输入和输出

#### 穿孔纸带

> 根据冯·诺依曼结构的要求，计算机所需要的数据首先要通过输入设备传输到存储器中。

<img src="1-6-1.jpg" />

> 除了输入设备I和输出设备O，冯·诺依曼还规定了一种**外部记录介质 R**。

<img src="1-6-2.jpg" />

#### 硬盘

<img src="1-6-3.jpg" />



> 现在计算机中很多设备既有输入也有输出的功能。

<img src="1-6-4.jpg" />



### 如何在模型机上添加 “输入输出设备” ？

> 首先，我们希望找到一种简单的输入输出方式。

#### 第一台微型计算机：Altair 8800

<img src="1-6-5.jpg" />

<img src="1-6-6.jpg" />

> 受Altair 8800的影响

<img src="1-6-7.jpg" />

#### 在模型机上添加一个简单的输入输出设备

<img src="1-6-8.jpg" />

#### 输入的简单场景

> 当前需要读取输入输出上8个手动开关的状态。

> CPU将地址发送到地址总线上。
>
> 在总线上会有一些简单的电路进行地址识别，可以发现这个地址应该发到输入输出部件而不是存储器。
>
> 与此同时，在控制总线上CPU会发出读的信号，从而告知输入输出设备目前是要进行一个读操作。
>
> 输入输出设备的控制逻辑和地址译码器就会从地址 1111 的单元中读出相应的信息，送到数据总线上。
>
> 数据总线会将这个数据最终送回到CPU中，这样就完成了输入信息的读取工作。

<img src="1-6-9.jpg" />

#### 输出的简单场景

> CPU给出输出单元对应的地址，这里是1110，送到地址总线上。
>
> 地址总线会将这个地址传送到输入输出设备。
>
> 同时控制总线上会给出写的控制信号。
>
> 数据总线上会给出我们想输出的数据，设为 11001100
>
> 然后输入输出设备就会根据总线给出的信息，判断出要像地址为 1110 的单元写入数据 11001100。
>
> 随后，就可以完成写入的操作，对应的小灯泡亮起。



### 输入输出设备

<img src="1-6-10.jpg" />

> 早期的个人计算机中，几乎每一个输入输出设备都需要通过对应的输入输出芯片或者板卡进行连接，例如单独的网卡、声卡等。

> 在现在的计算机中，大多数的输入输出芯片都会集中在主板上的**南桥芯片**中。
>
> 对于一些比较复杂的输入输出需求，比如高性能的显示，还是需要独立的板卡与外部的设备进行相连。

<img src="1-6-11.jpg" />



## 第七节 冯·诺依曼结构与具体实现

### 冯·诺依曼结构原理与实现的对应

#### 南北桥架构

<img src="1-7-1.jpg" />

#### 南北桥架构的演变

<img src="1-7-2.jpg" />

<img src="1-7-3.jpg" />

<img src="1-7-4.jpg" />

#### 系统芯片（SoC，System-on-a-Chip）

<img src="1-7-5.jpg" />



### 摩尔定律（Moore's Law）

#### 摩尔定律的原型

<img src="1-7-6.jpg">

#### 摩尔定律的演变

<img src="1-7-7.jpg" />



#### 计算机性能的增长

<img src="1-7-8.jpg" />



#### 微处理器晶体管数的增长情况

<img src="1-7-9.jpg" />

